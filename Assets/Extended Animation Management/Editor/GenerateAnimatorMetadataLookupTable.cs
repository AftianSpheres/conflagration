#if UNITY_EDITOR
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Text;
using UnityEngine;
using UnityEditor;
using UnityEditor.Animations;
using UnityEditor.Build;
using UnityEditor.Callbacks;
using CnfBattleSys;
using ExtendedAnimationManagement;

/// <summary>
/// Generates AnimatorMetadataLookupTable.cs and registers all AnimatorController assets.
/// </summary>
public class GenerateAnimatorMetadataLookupTable : IPreprocessBuild
{
    int IOrderedCallback.callbackOrder { get { return 0; } }
    private static string classComment = "<summary> Static class containing animator metadata definitions. Automatically generated. </summary>";
    private static string className = "AnimatorMetadataLookupTable";
    private static string outputName = "AnimatorMetadataLookupTable.cs";
    private static string path = "/Extended Animation Management/Scripts/Autogenerated/";
    private static CodeCompileUnit cu = new CodeCompileUnit();
    private static CodeGeneratorOptions options = new CodeGeneratorOptions();
    private static Microsoft.CSharp.CSharpCodeProvider csProvider = new Microsoft.CSharp.CSharpCodeProvider();
    private static StringWriter writer;
    private static bool built { get { return writer != null; } }
    private static int guidCount = 0;

    /// <summary>
    /// IPreprocessBuild.OnPreprocessBuild (target, path)
    /// </summary>
    void IPreprocessBuild.OnPreprocessBuild (BuildTarget target, string path)
    {
        GenerateSource();   
    }

    /// <summary>
    /// OnPostProcessScene ()
    /// </summary>
    [PostProcessScene]
    public static void OnPostProcessScene ()
    {
        GenerateSource();
    }

    /// <summary>
    /// Clears the StringWriter to force a rebuild,
    /// then rebuilds.
    /// </summary>
    public static void Refire ()
    {
        writer = null;
        GenerateSource();
    }

    /// <summary>
    /// Generate the source file and save it.
    /// </summary>
    private static void GenerateSource ()
    {
        if (!built)
        {
            CodeMemberField lookupTableDeclaration = new CodeMemberField(typeof(AnimatorMetadata[]), "lookupTable");
            lookupTableDeclaration.Comments.Add(new CodeCommentStatement(new CodeComment("<summary> The table of animator metadata. Each animator controller automatically has a MetadataPusher attached to it, which has its index in this table. </summary>")));
            lookupTableDeclaration.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static;
            lookupTableDeclaration.InitExpression = GenerateLookupTableAndRegisterAnimatorControllers();
            CodeTypeDeclaration classDeclaration = new CodeTypeDeclaration(className);
            classDeclaration.IsClass = true;
            classDeclaration.Attributes = MemberAttributes.Public;
            classDeclaration.Members.Add(lookupTableDeclaration);
            classDeclaration.Comments.Add(new CodeCommentStatement(classComment, true));
            CodeNamespace namespaceDeclaration = new CodeNamespace("ExtendedAnimationManagement");
            namespaceDeclaration.Types.Add(classDeclaration);
            writer = new StringWriter(new StringBuilder(512 * guidCount));
            options.VerbatimOrder = true;
            options.BlankLinesBetweenMembers = false;
            cu.Namespaces.Add(namespaceDeclaration);
            csProvider.GenerateCodeFromCompileUnit(cu, writer, options);
            FileStream fs = File.OpenWrite(Application.dataPath + path + outputName);
            StreamWriter sw = new StreamWriter(fs);
            fs.Position = 0;
            sw.Write(writer.ToString().Replace("public class AnimatorMetadataLookupTable", "public static class AnimatorMetadataLookupTable")); // this will never not be the worst
            sw.Dispose();
            fs.Dispose();
            AssetDatabase.Refresh();
            //Debug.Log("Generated AnimatorMetadataLookupTable.cs");
        }
    }

    /// <summary>
    /// Pull every animator controller in the project folder, register it with its index in the lookup table, and
    /// return the C# declaration of the lookup table.
    /// </summary>
    /// <returns></returns>
    private static CodeArrayCreateExpression GenerateLookupTableAndRegisterAnimatorControllers ()
    {
        string[] guidList = AssetDatabase.FindAssets("t:RuntimeAnimatorController");
        guidCount = guidList.Length;
        CodeObjectCreateExpression[] metadataDeclarations = new CodeObjectCreateExpression[guidList.Length];
        for (int i = 0; i < guidList.Length; i++)
        {
            AnimatorController animatorController = AssetDatabase.LoadAssetAtPath<AnimatorController>(AssetDatabase.GUIDToAssetPath(guidList[i]));
            RegisterAnimatorController(animatorController, i);
            
            metadataDeclarations[i] = DeclareMetadataFor(animatorController);
        }
        return new CodeArrayCreateExpression(typeof(AnimatorMetadata), metadataDeclarations);
    }

    /// <summary>
    /// Returns a CodeObjectCreateExpression that declares the metadata for the animatorController.
    /// </summary>
	private static CodeObjectCreateExpression DeclareMetadataFor (AnimatorController animatorController)
    {
        CodeArrayCreateExpression[] layerDeclarations = new CodeArrayCreateExpression[animatorController.layers.Length];
        for (int l = 0; l < animatorController.layers.Length; l++)
        {      
            ChildAnimatorState[] states = animatorController.layers[l].stateMachine.states;

            CodeObjectCreateExpression[] thisLayerDeclarationsArray = new CodeObjectCreateExpression[states.Length];
            for (int s = 0; s < states.Length; s++)
            {
                CodePrimitiveExpression fullPath = new CodePrimitiveExpression(animatorController.layers[l].name + "." + states[s].state.name);
                CodePrimitiveExpression name = new CodePrimitiveExpression(states[s].state.name);
                thisLayerDeclarationsArray[s] = new CodeObjectCreateExpression(typeof(AnimatorMetadata.StateMetadata), new CodeExpression[] { fullPath, name });
            }
            layerDeclarations[l] = new CodeArrayCreateExpression(typeof(AnimatorMetadata.StateMetadata[]), thisLayerDeclarationsArray);
        }
        return CreateWithEventMappings(animatorController, new CodeArrayCreateExpression(typeof(AnimatorMetadata.StateMetadata[][]), layerDeclarations));
    }

    /// <summary>
    /// Make sure the animator controller has a metadata pusher on layer 0, and
    /// associate it with the appropriate index in the metadata lookup table.
    /// </summary>
    private static void RegisterAnimatorController (AnimatorController animatorController, int index)
    {
        StateMachineBehaviour[] layer0Behaviours = animatorController.layers[0].stateMachine.behaviours;
        StateMachineExtender metadataPusher = null;
        for (int i = 0; i < layer0Behaviours.Length; i++)
        {
            if (layer0Behaviours[i] is StateMachineExtender)
            {
                metadataPusher = (StateMachineExtender)layer0Behaviours[i];
                break;
            }
        }
        if (metadataPusher == null) metadataPusher = animatorController.layers[0].stateMachine.AddStateMachineBehaviour<StateMachineExtender>();
        metadataPusher.tableIndex_SetAutomatically = index;
        EditorUtility.SetDirty(animatorController);
    }

    /// <summary>
    /// Gets all the anim event mappings for the given animator controller.
    /// </summary>
    private static CodeObjectCreateExpression CreateWithEventMappings (AnimatorController animatorController, CodeExpression layerDeclarations)
    {
        Dictionary<AnimatorState, AnimatorControllerLayer> layerMap = new Dictionary<AnimatorState, AnimatorControllerLayer>();
        Dictionary<AnimEventType, List<AnimatorState>> bindings = new Dictionary<AnimEventType, List<AnimatorState>>();
        Func<StateMachineBehaviour[], AnimEventBinder> containsBehaviour = (behaviourSet) => 
        {
            for (int i = 0; i < behaviourSet.Length; i++)
                if (behaviourSet[i].GetType() == typeof(AnimEventBinder)) return (AnimEventBinder)behaviourSet[i];
            return null;
        };
        Func<AnimatorControllerLayer, AnimatorState, int> getFullPathHash = (layer, state) =>
        {
            return Animator.StringToHash(layer.name + "." + state.name);
        };
        for (int l = 0; l < animatorController.layers.Length; l++)
        {
            for (int s = 0; s < animatorController.layers[l].stateMachine.states.Length; s++)
            {
                AnimEventBinder binder = containsBehaviour(animatorController.layers[l].stateMachine.states[s].state.behaviours);
                if (binder != null)
                {
                    for (int a = 0; a < binder.animEventTypes.Length; a++)
                    {
                        if (!bindings.ContainsKey(binder.animEventTypes[a])) bindings.Add(binder.animEventTypes[a], new List<AnimatorState>());
                        bindings[binder.animEventTypes[a]].Add(animatorController.layers[l].stateMachine.states[s].state);
                        layerMap.Add(animatorController.layers[l].stateMachine.states[s].state, animatorController.layers[l]);
                    }
                    
                }
            }
        }
        AnimEventType[] boundAnimEvents = new AnimEventType[bindings.Keys.Count];
        int[][] hashSets = new int[boundAnimEvents.Length][];
        CodeFieldReferenceExpression[] eventsRefs = new CodeFieldReferenceExpression[boundAnimEvents.Length];
        CodePrimitiveExpression[][] hashRefs = new CodePrimitiveExpression[hashSets.Length][];
        CodeArrayCreateExpression[] subarrays = new CodeArrayCreateExpression[hashRefs.Length];
        bindings.Keys.CopyTo(boundAnimEvents, 0);
        for (int i = 0; i < boundAnimEvents.Length; i++)
        {
            hashSets[i] = new int[bindings[boundAnimEvents[i]].Count];
            for (int s = 0; s < hashSets[i].Length; s++)
            {
                hashSets[i][s] = getFullPathHash(layerMap[bindings[boundAnimEvents[i]][s]], bindings[boundAnimEvents[i]][s]);
            }
            eventsRefs[i] = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(AnimEventType)), boundAnimEvents[i].ToString());
            hashRefs[i] = new CodePrimitiveExpression[hashSets[i].Length];
            for (int h = 0; h < hashSets[i].Length; i++) hashRefs[i][h] = new CodePrimitiveExpression(hashSets[i][h]);
            subarrays[i] = new CodeArrayCreateExpression(typeof(int[]), hashRefs[i]);
        }
        CodeExpression hashesMultiArrayDeclaration;
        // If subarrays.Length == 0, CodeDOM will "optimize" this argument straight into a type mismatch!
        // This is a hack that works around that by making sure we explicitly declare an empty array-of-arrays,
        // if need be.
        if (subarrays.Length > 0) hashesMultiArrayDeclaration = new CodeArrayCreateExpression(typeof(int[][]), subarrays);
        else hashesMultiArrayDeclaration = new CodeSnippetExpression("new int[0][]");
        return new CodeObjectCreateExpression(typeof(AnimatorMetadata), new CodeExpression[] { layerDeclarations,
            new CodeArrayCreateExpression(typeof(AnimEventType), eventsRefs), hashesMultiArrayDeclaration });
    }
}

#endif